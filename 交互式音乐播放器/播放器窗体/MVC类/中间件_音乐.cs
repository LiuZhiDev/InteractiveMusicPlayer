using NAudio.Wave;
using Panuon.UI.Silver;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using 交互式音乐播放器.文件浏览中间件;
using 交互式音乐播放器.设置类;

namespace 交互式音乐播放器.音频中间件
{
    public class 音频信息
    {
        public bool 配置文件启用 { get; set; }
        /// <summary>
        /// 设置曲名
        /// </summary>
        public string 曲名 { get; set; }
        /// <summary>
        /// 设置播放列表
        /// </summary>
        public List<string> 播放列表 { get; set; }
        /// <summary>
        /// 设置音频的类型,该项控制音频会使用什么形式进行播放
        /// </summary>
        public 语言.音频类型.循环类型 音频类型 { get; set; }
        public 语言.音频类型.文件模式 文件模式 { get; set; }
        public 文件信息.项目类型 文件格式 { get; set; }
        public 语言.音频状态.播放状态 音频状态 { get; set; }
        /// <summary>
        /// 设置音频文件开始的偏移量
        /// </summary>
        public int 初始文件偏移 { get; set; } = 0;
        /// <summary>
        /// 即将被弃用，设置Ogg类循环文件在第二次循环，计算节拍时代偏移
        /// </summary>
        public long 偏移 { get; set; } = 0;
        /// <summary>
        /// 设置音频的BPM，默认为120.
        /// </summary>
        public int BPM { get; set; } = 120;
        /// <summary>
        /// 设置音频当前的小节数
        /// </summary>
        public int 当前小节 { get; set; } = -1;
        /// <summary>
        /// 设置音频当前的拍数
        /// </summary>
        public int 当前拍数 { get; set; } = -1;
        /// <summary>
        /// 设置音频每一拍所需要的毫秒数
        /// </summary>
        public double 每拍毫秒 { get; set; }
        /// <summary>
        /// 本章节每小节总拍数
        /// </summary>
        public int 当前章节拍数 { get; set; } = 4;
        /// <summary>
        /// <summary>
        /// 设置音频的持续时间
        /// </summary>
        public TimeSpan 持续时长 { get; set; }
        /// <summary>
        /// 设置音频当前播放的进度
        /// </summary>
        public TimeSpan 当前时长 { get; set; }
        /// <summary>
        /// 程序当前播放的字节位置
        /// </summary>
        public double 当前播放位置 = 0;
        /// <summary>
        /// 设置音频当前已经循环的次数
        /// </summary>
        public int 循环次数 { get; set; }
        /// <summary>
        /// 音频被划分的总章节数
        /// </summary>
        public int 章节_总数 { get; set; }
        /// <summary>
        /// 音频当前播放的章节编号
        /// </summary>
        public int 章节_当前编号 { get; set; }
        /// <summary>
        /// 音频即将要播放的章节编号
        /// </summary>
        public int 章节_下一编号 { get; set; }
        /// <summary>
        /// 音频的每采样字节
        /// </summary>
        public int 每采样字节 { get; set; } = 10;
        /// <summary>
        /// 设置音频每一拍的Bit数，用于精确计算拍数切换。
        /// </summary>
        public double 每拍Bit { get; set; } = -1;
        /// <summary>
        /// 设置章节在哪一拍进行切换
        /// </summary>
        public int 切换点拍数 { get; set; } = 0;
        /// <summary>
        /// 即将弃用，设置切换点是否在最后一拍
        /// </summary>
        public bool 切换点在末拍 = false;
        /// <summary>
        /// 设置音频淡入时所过渡过去的拍数
        /// </summary>
        public int 淡入_拍数 { get; set; } = 0;
        /// <summary>
        /// 设置音频淡出时所过渡过去的拍数
        /// </summary>
        public int 淡出_拍数 { get; set; } = 0;
        /// <summary>
        /// 设置音频在本次章节循环后停止，或进入停止逻辑
        /// </summary>
        public bool 准备停止 { get; set; } = false;
        /// <summary>
        /// 设置音频流是否还需要被读取
        /// 已过时，不建议使用。
        /// </summary>
        public bool _仍需读取流 { get; set; } = true;
        /// <summary>
        ///  控制字节流的移交状态，若为true，说明该字节流已移交，将在播放完剩下的字节流后结束播放。
        ///  和“仍需读取流”不同的是，“字节流移交”仍会持续播放完剩下的字节流。
        /// </summary>
        public bool 字节流移交 { get; set; } = false;
        /// <summary>
        /// 仅多文件模式使用，设置需要循环的文件下标
        /// </summary>
        public List<int> 循环文件下标 { get; set; } = new List<int>();
        /// <summary>
        /// 仅单一文件模式使用，设置需要循环的字节段
        /// </summary>
        public List<int> 字节分割 { get; set; } = new List<int>();
        /// <summary>
        /// 设置章节的名称信息
        /// </summary>
        public List<string> 章节信息 { get; set; } = new List<string>();
        public List<int> 章节节拍数 { get; set; } = new List<int>();
        /// <summary>
        /// 设置音频在章节切换时是否有过渡音频，若为是，过渡音频将会被播放
        /// </summary>
        public bool 启用过渡音频 { get; set; } = false;
        public bool 正在切换章节 { get; set; } = false;
        /// <summary>
        /// 指示音频正在等待它的过渡效果音
        /// </summary>
        public bool 等待过渡音频 { get; set; } = false;
        /// <summary>
        /// 指示在某章节中的节拍特例
        /// </summary>
        public List<string> 节拍特例 { get; set; } = new List<string>();
        /// <summary>
        /// 线程号，即将被弃用
        /// </summary>
        public int 线程号 = 0;
        /// <summary>
        /// 是否在播放下一拍后切换到新的章节
        /// </summary>
        public bool 播放下一拍后跳转 { get; set; } = false;
        /// <summary>
        /// 当前UI绑定的线程号，即将被弃用
        /// </summary>
        public int 当前UI绑定线程 = 0;
        /// <summary>
        /// 程序内的淡入效果正在进行
        /// </summary>
        public bool 已在淡入 = false;
        /// <summary>
        /// 程序内的淡出效果正在进行
        /// </summary>
        public bool 已在淡出 = false;
        /// <summary>
        /// 程序内的淡入淡出字节修改量
        /// </summary>
        public int 淡入_字节修改量 { get; set; } = 0;
        /// <summary>
        /// 程序内的淡入淡出字节修改量
        /// </summary>
        public int 淡出_字节修改量 { get; set; } = 0;


    }
    internal class 音频文件播放
    {

        public static MainWindow 控件集;
        public static 音频信息 状态;
        public delegate void 前台信息更新(音频信息 状态);
        public static 前台信息更新 更新UI;
        public delegate void 下一音频();
        public static 下一音频 播放下一音频;
        public static object 播放流;
        public static object 播放控制;

        public 音频文件播放(控件.音频文件项 音频文件项, MainWindow 窗体, 音频信息 状态, 前台信息更新 UI更新)
        {
            if (状态 == null)
            {
                return;
            }
            控件集 = 窗体;
            更新UI = UI更新;
            音频文件播放.状态 = 状态;
            读取配置档案(状态, 音频文件项);
            设置UI组件(音频文件项, 状态, 控件集);
            //其他音频逻辑接口入口
            打开播放组件();
            通用UI更新(状态);
        }

        public void 读取配置档案(音频信息 状态, 控件.音频文件项 音频文件项)
        {
            #region 基础信息读取
            状态.曲名 = 音频文件项.曲名.Text;
            状态.播放列表 = 音频文件项.文件路径;
            if (状态.播放列表.Count <= 1)
            {
                状态.文件模式 = 语言.音频类型.文件模式.单一文件模式;
            }
            if (状态.播放列表.Count > 1)
            {
                状态.文件模式 = 语言.音频类型.文件模式.多个文件模式;
            }

            #endregion
            #region 读取配置文件

            //【接入点】此处可以添加音频配置文件的代码
            配置文件.配置档.读取音频配置(音频文件项, 状态);


            日志.输出(状态.音频类型);
            #endregion
        }

        public void 设置UI组件(控件.音频文件项 音频文件项, 音频信息 状态, MainWindow 控件集)
        {
            控件集.当前播放专辑图.ImageSource = 音频文件项.专辑图片.ImageSource;
            控件集.曲名.Text = 音频文件项.曲名.Text;
            if (设置类.设置.循环模式 != 语言.音频类型.循环类型.列表循环)
            {
                控件集.循环模式.Content = 音频文件项.循环类型.Content;
            }
            控件集.进度条.Value = 0;

            if (状态.音频类型 == 语言.音频类型.循环类型.不可循环)
            {
                if (设置类.设置.循环模式 != 语言.音频类型.循环类型.列表循环)
                {
                    ButtonHelper.SetIcon(控件集.循环模式, 语言.图标.不可循环图标);
                }
                控件集.段落切换按钮.Content = "➡️ 默认段落";
            }
            //更新章节信息
            int tmpvalue = 0;
            控件集.章节集.Items.Clear();
            foreach (var tmp in 状态.章节信息)
            {
                MenuItem 菜单 = new MenuItem();
                菜单.Header = tmp;
                菜单.Tag = tmpvalue;
                菜单.Click += 切换到菜单的章节;
                控件集.章节集.Items.Add(菜单);
                tmpvalue += 1;
            }


        }

        private void 切换到菜单的章节(object sender, RoutedEventArgs e)
        {
            var tmp = (MenuItem)sender;
            播放状态管理.执行段落切换( 状态,(int)tmp.Tag);
        }

        public void 打开播放组件()
        {
            if (状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                流.MP3.永续控制 MP3流 = new 流.MP3.永续控制(状态.播放列表, false);
                播放控制 = MP3流;
                状态.音频状态 = 语言.音频状态.播放状态.播放中;
            }
            if (状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续控制 永续流 = new 流.永续.永续控制(状态.播放列表);
                    播放控制 = 永续流;
                    状态.音频状态 = 语言.音频状态.播放状态.播放中;
                }
                if (状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    var 播放状态 = new 流.交互式无缝循环.状态();
                    播放状态.章节BPM = 状态.BPM;
                    播放状态.章节节拍 = 状态.当前章节拍数;
                    流.交互式无缝循环.交互式无缝循环控制 交互流 = new 流.交互式无缝循环.交互式无缝循环控制(状态.播放列表, 状态.循环文件下标, 播放状态);
                    播放控制 = 交互流;
                    状态.音频状态 = 语言.音频状态.播放状态.播放中;
                }
                if (状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    流.高低切换.高低切换式控制 步进流 = new 流.高低切换.高低切换式控制(状态.播放列表);
                    播放控制 = 步进流;
                    状态.音频状态 = 语言.音频状态.播放状态.播放中;
                }

            }

        }
        public static void 通用UI更新(音频信息 状态)
        {
            Thread thread = new Thread(() =>
            {
                日志.输出("UI更新已启动");
                while (!(状态.音频状态 == 语言.音频状态.播放状态.停止中))
                {
                    播放状态管理.返回UI信息(状态);
                    更新UI(状态);
                    Thread.Sleep(100);
                }
            });
            thread.Start();
            日志.输出("UI更新已停止");
        }


    }
    internal class 播放线程管理
    {
        public static void 关闭所有播放内容()
        {
            播放状态管理.停止处理();
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                while (!(流.MP3.永续控制.永续流.播放器.PlaybackState == PlaybackState.Stopped))
                {
                    Thread.Sleep(100);
                }
                流.MP3.永续式.运行状态.状态 = 流.MP3.永续式.运行状态.播放状态.播放;
            }
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续式.运行状态.状态 = 流.永续.永续式.运行状态.播放状态.停止;
                    while (!(流.永续.永续控制.播放器.PlaybackState == PlaybackState.Stopped))
                    {
                        Thread.Sleep(100);
                    }
                    流.永续.永续式.运行状态.状态 = 流.永续.永续式.运行状态.播放状态.播放;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    流.交互式无缝循环.状态.当前状态 = 流.交互式无缝循环.状态.播放状态.停止;
                    while (!(流.交互式无缝循环.交互式无缝循环控制.播放器.PlaybackState == PlaybackState.Stopped))
                    {
                        Thread.Sleep(100);
                    }
                    流.交互式无缝循环.状态.当前状态 = 流.交互式无缝循环.状态.播放状态.播放;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    foreach (var tmp in 流.高低切换.高低切换式控制.播放器组.Values)
                    {
                        while (!(tmp.PlaybackState == PlaybackState.Stopped))
                        {
                            Thread.Sleep(50);
                        }
                    }
                    流.交互式无缝循环.状态.当前状态 = 流.交互式无缝循环.状态.播放状态.播放;
                }
            }
        }


    }
    public static class 播放状态管理
    {
        public static void 调整播放进度(double 播放进度)
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                流.MP3.永续控制.永续流.MP3读取器组[流.MP3.永续控制.永续流.当前播放章节].Position =
                    (long)(流.MP3.永续控制.永续流.MP3读取器组[流.MP3.永续控制.永续流.当前播放章节].Length * 播放进度);
            }
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续控制.永续流.OGG读取器组[流.永续.永续控制.永续流.当前播放章节].Position =
                         (long)(流.永续.永续控制.永续流.OGG读取器组[流.永续.永续控制.永续流.当前播放章节].Length * 播放进度);
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    流.交互式无缝循环.交互式无缝循环控制.交互流.OGG读取器组[流.交互式无缝循环.交互式无缝循环控制.交互流.当前播放章节].Position =
                         (long)(流.交互式无缝循环.交互式无缝循环控制.交互流.OGG读取器组[流.交互式无缝循环.交互式无缝循环控制.交互流.当前播放章节].Length * 播放进度);
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    foreach (var tmp in 流.高低切换.高低切换式控制.实例组.Values)
                    {
                        tmp.OGG读取器.Position = (long)(tmp.OGG读取器.Length * 播放进度);

                    }
                }
            }
        }
        public static void 执行段落切换()
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    if (音频文件播放.状态.章节_当前编号 == 流.交互式无缝循环.交互式无缝循环控制.交互流.OGG读取器组.Count - 1)
                    {
                        音频文件播放.状态.正在切换章节 = true;
                        MessageBox.Show("这已经是最后一个章节了", "不可切换");
                        音频文件播放.状态.正在切换章节 = false;
                        return;
                    }
                    流.交互式无缝循环.交互式无缝循环控制.准备切换章节();
                    音频文件播放.状态.正在切换章节 = true;

                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    音频文件播放.状态.正在切换章节 = true;
                    流.高低切换.高低切换式控制.自动高低切换();
                }

            }
        }

        public static void 执行段落切换(音频信息 状态,int 章节号)
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    MessageBox.Show("无缝章节循环是连贯的，不可以跨章节切换", "不可切换");
                    return;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    音频文件播放.状态.正在切换章节 = true;
                    流.高低切换.高低切换式控制.高低切换(章节号);
                    状态.章节_当前编号 = 章节号;
                    
                }

            }
        }
        public static void 调整音量(文件信息.项目类型 项目类型, int 音量值)
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                var 控制器 = (流.MP3.永续控制)音频文件播放.播放控制;
                控制器.设置音量(音量值);
            }
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续控制.播放器.Volume = 音量值 / 100f;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    流.交互式无缝循环.交互式无缝循环控制.播放器.Volume = 音量值 / 100f;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    流.高低切换.高低切换式控制.播放器组[0].Volume = 音量值 / 100f;
                }
            }

        }



        public static void 播放处理()
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                流.MP3.永续式.运行状态.状态 = 流.MP3.永续式.运行状态.播放状态.播放;
                音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.播放中;
            }
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续式.运行状态.状态 = 流.永续.永续式.运行状态.播放状态.播放;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.播放中;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    流.交互式无缝循环.状态.当前状态 = 流.交互式无缝循环.状态.播放状态.播放;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.播放中;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    流.高低切换.高低切换式.运行状态.状态 = 流.高低切换.高低切换式.运行状态.播放状态.播放;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.播放中;
                }
            }
        }
        public static void 暂停处理()
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                流.MP3.永续式.运行状态.状态 = 流.MP3.永续式.运行状态.播放状态.暂停;
                音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.暂停中;
            }
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续式.运行状态.状态 = 流.永续.永续式.运行状态.播放状态.暂停;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.暂停中;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    流.交互式无缝循环.状态.当前状态 = 流.交互式无缝循环.状态.播放状态.暂停;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.暂停中;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    流.高低切换.高低切换式.运行状态.状态 = 流.高低切换.高低切换式.运行状态.播放状态.暂停;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.暂停中;
                }
            }
        }
        public static void 停止处理()
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                流.MP3.永续式.运行状态.状态 = 流.MP3.永续式.运行状态.播放状态.停止;
                音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.停止中;
            }
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    流.永续.永续式.运行状态.状态 = 流.永续.永续式.运行状态.播放状态.停止;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.停止中;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    流.交互式无缝循环.状态.当前状态 = 流.交互式无缝循环.状态.播放状态.停止;
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.停止中;
                }
                if (音频文件播放.状态.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    流.高低切换.高低切换式.运行状态.状态 = 流.高低切换.高低切换式.运行状态.播放状态.停止;
                    foreach (var tmp in 流.高低切换.高低切换式控制.播放器组.Values)
                    {
                        while (!(tmp.PlaybackState == PlaybackState.Stopped))
                        {
                            Thread.Sleep(100);
                        }
                    }
                    音频文件播放.状态.音频状态 = 语言.音频状态.播放状态.停止中;
                    流.高低切换.高低切换式.运行状态.状态 = 流.高低切换.高低切换式.运行状态.播放状态.播放;

                }
            }
        }

        public static void 返回UI信息(音频信息 信息)
        {
            if (音频文件播放.状态.文件格式 == 文件信息.项目类型.MP3文件)
            {
                var 当前流 = 流.MP3.永续控制.永续流;
                var 读取器组 = 流.MP3.永续控制.永续流.MP3读取器组;
                信息.当前时长 = 读取器组[当前流.当前播放章节].CurrentTime;
                信息.持续时长 = 读取器组[当前流.当前播放章节].TotalTime;
                #region 辅助功能模块
                //循环功能模块
                if (信息.当前时长 == 信息.持续时长)
                {
                    信息.音频状态 = 语言.音频状态.播放状态.停止中;
                    音频文件播放.控件集.Dispatcher.Invoke((ThreadStart)delegate ()
                    {
                        if (设置类.设置.循环模式 == 语言.音频类型.循环类型.列表循环) { 音频文件播放.播放下一音频(); }
                    });
                    if (设置类.设置.循环模式 == 语言.音频类型.循环类型.强制循环)
                    {
                        读取器组[当前流.当前播放章节].Position = 0;
                        当前流.播放器.Play();
                        信息.音频状态 = 语言.音频状态.播放状态.播放中;
                        信息.循环次数++;
                        音频文件播放.更新UI(信息);
                    }
                }
                #endregion

            }
            if (信息.文件格式 == 文件信息.项目类型.OGG文件)
            {
                if (信息.音频类型 == 语言.音频类型.循环类型.永续)
                {
                    var 当前流 = 流.永续.永续控制.永续流;
                    var 读取器组 = 流.永续.永续控制.永续流.OGG读取器组;
                    信息.当前时长 = 读取器组[当前流.当前播放章节].CurrentTime;
                    信息.持续时长 = 读取器组[当前流.当前播放章节].TotalTime;
                    信息.循环次数 = 当前流.循环次数;
                    信息.章节_当前编号 = 当前流.当前播放章节; 
                }
                if (信息.音频类型 == 语言.音频类型.循环类型.无缝章节循环)
                {
                    var 当前流 = 流.交互式无缝循环.交互式无缝循环控制.交互流;
                    var 读取器组 = 流.交互式无缝循环.交互式无缝循环控制.交互流.OGG读取器组;
                    信息.当前时长 = 读取器组[当前流.当前播放章节].CurrentTime;
                    信息.持续时长 = 读取器组[当前流.当前播放章节].TotalTime;
                    信息.循环次数 = 当前流.取出循环次数(当前流.当前播放章节);
                    信息.当前小节 = 当前流.播放状态.当前小节;
                    信息.当前拍数 = 当前流.播放状态.当前拍;
                    if (信息.章节_当前编号 != 当前流.当前播放章节)
                    {
                        信息.正在切换章节 = false;
                        信息.章节_当前编号 = 当前流.当前播放章节;
                    }
                }
                if (信息.音频类型 == 语言.音频类型.循环类型.步进循环)
                {
                    if (流.高低切换.高低切换式控制.实例组.Count <= 0) { return; }
                    var 当前流 = 流.高低切换.高低切换式控制.实例组[0];
                    var 读取器组 = 流.高低切换.高低切换式控制.实例组[流.高低切换.高低切换式控制.当前章节].OGG读取器;
                    try
                    {
                        if (当前流.播放器.PlaybackState == PlaybackState.Playing && 当前流.播放器.GetPosition() > 500)
                        {
                            信息.当前时长 = 读取器组.CurrentTime;
                            信息.持续时长 = 读取器组.TotalTime;
                            信息.循环次数 = 当前流.循环次数;
                            信息.章节_当前编号 = 流.高低切换.高低切换式控制.当前章节;

                            var 切换时值 = 0;
                            foreach (var tmp in 流.高低切换.高低切换式控制.实例组.Values)
                            {
                                切换时值 += (int)tmp.已淡入淡出段数;//仅借用变量值
                            }

                            if (切换时值 > 20) { 信息.正在切换章节 = false; }//仅借用变量值

                        }

                    }
                    //屏蔽错误，不知道如何修复
                    catch { 日志.输出("更新步进切换UI信息时，出现异常，当前流不可用"); return; }


                }
            }

        }

    }

}
